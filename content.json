[{"title":"一文理解Cookie","date":"2020-02-14T12:39:30.000Z","path":"2020/02/14/一文理解Cookie/","text":"1.背景写项目的过程中，遇到了向客户端写入Cookie的相关知识。Cookie这个知识点一直理解得都不是太清楚，趁着这一次又遇到了这一知识点，想着写下这篇博客记录一下。在学习这个知识点前，我们应该明白自己的学习目标，要带着疑问去学习，所以关于Cookie我们要了解： 什么是cookie，cookie的作用； cookie的工作机制，即cookie是运作流程； cookie的基本属性（4个）以及我们如何使用cookie。 2. 什么是Cookie学习Cookie之前，我们需要对HTTP协议有基本的了解。我们知道，HTTP协议本身是无状态的。那么什么是无状态的呢？即服务器无法判断用户身份。 要想服务器能够判断用户身份，这时就要使用到Cookie，Cookie实际上是一小段的文本信息（key-value格式）。 客户端（浏览器）向服务器发起请求，如果服务器需要记录该用户状态，就使用response对象向客户端颁发一个Cookie。客户端会把Cookie保存起来。当客户端再请求该网站时，客户端会把请求的网址和该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。 举个例子，我们去银行办理储蓄业务，第一次给你办了张银行卡，卡里存放了身份证、密码、手机等个人信息。当你下次再来这个银行时，银行机器能识别你卡里的信息，即能够辨认你的身份，从而能够直接办理业务。 3. Cookie机制当用户第一次访问并登陆一个网站的时候，Cookie的设置及发送会经历以下4个步骤： 客户端发送一个请求到服务器； 服务器发送一个HttpResponse响应到客户端，其中包含Set-Cookie的头部； 客户端保存Cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部； 服务器返回响应数据。 这4个步骤如图所示： 4. cookie属性项 属性项 属性项介绍 NAME=VALUE 键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样 Expires Cookie的有效期，在设置的某个时间点后该 Cookie 就会失效 Domain 生成该 Cookie 的域名，如 domain=”www.baidu.com“ Path 该 Cookie 是在当前的哪个路径下生成的，如 path=/，表示所有请求都带Cookie Secure 如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie Expires： 该属性用来设置Cookie的有效期。Cookie中的maxAge用来表示该属性，单位为秒。Cookie中通过getMaxAge()和setMaxAge(int maxAge)来读写该属性； maxAge有3种值，分别为正数，负数和0； maxAge为正数：则表示该Cookie会在maxAge秒之后自动失效。浏览器会将maxAge为正数的Cookie持久化，即写到对应的Cookie文件中（每个浏览器存储的位置不一致）。无论客户关闭了浏览器还是电脑，只要还在maxAge秒之前，登录网站时该Cookie仍然有效。代码如下所示： 1234Cookie cookie = new Cookie(\"test\",System.currentTimeMillis()+\"\");//设置生命周期为MAX_VALUE，永久有效cookie.setMaxAge(Integer.MAX_VALUE);response.addCookie(cookie); maxAge为负数：则表示该Cookie只是一个临时Cookie，不会被持久化，仅在本浏览器窗口或者本窗口打开的子窗口中有效，关闭浏览器后该Cookie立即失效，代码如下所示： 1234Cookie cookie = new Cookie(\"test\",System.currentTimeMillis()+\"\");//MaxAge为负数，是一个临时Cookie，不会持久化cookie.setMaxAge(-1);response.addCookie(cookie); maxAge为0：表示立即删除Cookie，代码如下所示： 1234567891011121314Cookie[] cookies = response.getCookies();Cookie cookie = null;//get Cookiefor (Cookie ck : cookies) &#123;if (\"mcrwayfun\".equals(ck.getName())) &#123; cookie = ck; break; &#125; &#125; if (null != cookie) &#123; //删除一个cookie cookie.setMaxAge(0); resp.addCookie(cookie);&#125; 那么maxAge设置为负值和0到底有什么区别呢？ maxAge设置为0表示立即删除该Cookie； maxAge设置为负数，能看到Expires属性改变了，但Cookie仍然会存在一段时间直到关闭浏览器或者重新打开浏览器。 修改或者删除Cookie： HttpServletResponse提供的Cookie操作只有一个addCookie(Cookie cookie)，所以想要修改Cookie只能使用一个同名的Cookie来覆盖原先的Cookie。如果要删除某个Cookie，则只需要新建一个同名的Cookie，并将maxAge设置为0，并覆盖原来的Cookie即可。 新建的Cookie，除了value、maxAge之外的属性，比如name、path、domain都必须与原来的一致才能达到修改或者删除的效果。否则，浏览器将视为两个不同的Cookie不予覆盖。 需要注意的是，从客户端读取Cookie时，包括maxAge在内的其他属性都是不可读的，也不会被提交。浏览器提交Cookie时只会提交name和value属性，maxAge属性只被浏览器用来判断Cookie是否过期，而不能用服务端来判断。 我们无法在服务端通过cookie.getMaxAge()来判断该Cookie是否过期，maxAge只是一个只读属性，值永远为-1。当Cookie过期时，浏览器在与后台交互时会自动筛选过期Cookie，过期了的Cookie就不会被携带了。 Cookie的域名： Cookie是不可以跨域名的，隐私安全机制禁止网站非法获取其他网站的Cookie； 正常情况下，同一个一级域名下的两个二级域名也不能交互使用Cookie，比如test1.helayxy.com和test2.helayxy.com，因为二者的域名不完全相同。如果想要helayxy.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数为.helayxy.com，这样使用test1.helayxy.com和test2.helayxy.com就能访问同一个cookie； 12一级域名又称为顶级域名，一般由字符串+后缀组成。熟悉的一级域名有baidu.com、jd.com等，com、cn、net等均是常见的后缀；二级域名是在一级域名下衍生的，比如有个一级域名为http://helayxy.com，则http://blog.helayxy.com和http://www.helayxy.com均是其衍生出来的二级域名。 Cookie的路径： path属性决定允许访问Cookie的路径。比如，设置为”/“表示允许所有路径都可以使用Cookie。","comments":true,"tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://helayxy.github.io/tags/Cookie/"}]},{"title":"int和Integer的区别及应用场景","date":"2020-02-07T08:36:00.000Z","path":"2020/02/07/int和Integer的区别及应用场景/","text":"1、背景： 让人懵逼又很基础的问题，为什么我代码中要用Integer而不是int？ 2、int与Integer区别： int属于基本数据类型，Integer属于int对应的包装类型； Integer需要实例化才可以使用，而int不需要； int的默认值是0，Integer的默认值是null。 3、int与Integer的应用场景： 基本数据类型：存放的是值，存放在栈中；但作为方法中的局部变量，存放在堆中； 对象类型：Integer是对对象的引用，对象存放在堆中； 堆和栈的区别： 栈： 栈的存取速度比堆快，仅次于直接位于CPU的寄存器； 栈中的数据的大小和生存周期是确定的； 栈中的数据可以共享。 堆： 堆可以动态地分配内存大小，生存周期不确定； 堆在运行时动态分配内存，存取速度较慢。 综上所述，可以简单的理解为，为了高效，可以把一些数值小，简单的变量存放在栈中。 4、有了基本数据类型为什么会出现包装类？ 在对象中可以定义更多的功能方法操作该数据； 编码过程中只接收对象的情况，例如集合中只能存入对象，不能存入基本数据类型； 泛型不支持基本数据类型。 5、使用场景 大部分的情况下，这两种类型没有太大的区别。根据以上的分析，基本类型的存取速度会更快，但操作对象（包装类型）有更多功能方法，所以要根据实际需要定义属性。 例如学生没来考试，成绩是0还是null，如果你觉得是0就用int，如果你认为是null，用Integer。","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"https://helayxy.github.io/tags/Java/"}]},{"title":"sql语句中#{}的用法","date":"2020-01-29T04:29:57.000Z","path":"2020/01/29/sql语句中-的用法/","text":"123451.parameterType=&quot;map&quot;：参数为map类型时，#&#123;&#125;括号内写map的key值2.parameterType=&quot;com.xy.pojo.CheckGroup&quot;：参数为实体类，#&#123;&#125;括号内写实体类的属性名3.parameterType=&quot;int&quot;：参数类型为简单类型时，包括int、string、long等，#&#123;&#125;括号内内可以随意写 使用动态SQL时，必须写value，如下所示： 1234567&lt;!--分页查询检查组--&gt;&lt;select id=\"findByCondition\" parameterType=\"string\" resultType=\"com.itheima.pojo.CheckGroup\"&gt; select * from t_checkgroup &lt;if test=\"value != null and value.length &gt; 0\"&gt; where code = #&#123;value&#125; or name = #&#123;value&#125; or helpCode = #&#123;value&#125; &lt;/if&gt;&lt;/select&gt;","comments":true,"tags":[{"name":"SQL","slug":"SQL","permalink":"https://helayxy.github.io/tags/SQL/"}]},{"title":"git push命令用法详解","date":"2020-01-29T04:26:01.000Z","path":"2020/01/29/git-push命令用法详解/","text":"作用：用于将本地分支的更新推送到远程主机 语法：git push &lt;远程主机名&gt; &lt;本地分支名&gt;：&lt;远程分支名&gt; 例子：git push origin master:master 注意：这里的:前后是必须没有空格的，git pull是:， git push是: 12git push origin master上述命令省略了远程分支名，表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 12git push origin ：refs/for/master上述命令省略了本地分支名，表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，相当于执行git push origin --delete master命令，表示删除origin主机的master分支。 12git push origin上述命令表示，将当前分支推送到origin主机的对应分支。如果当前分支与远程分支之间存在追踪关系，则本地分支名和远程分支名都可以省略。 12git push如果当前分支只有一个远程分支，那么主机名都可以省略，可以使用git branch -r查看远程的分支名。 12git push -u origin master如果当前分支与多个主机存在追踪关系，则可以使用-u参数指定一个默认主机，以后就可以直接使用git push命令了。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://helayxy.github.io/tags/Git/"}]},{"title":"基于LinkedList实现队列和栈数据结构","date":"2020-01-06T14:05:50.000Z","path":"2020/01/06/基于LinkedList实现队列和栈数据结构/","text":"需求：基于LinkedList实现队列数据结构 队列数据结构特点：先进先出 代码实现： 1234567891011121314151617181920212223package com.linkedlistdemo;import java.util.LinkedList;public class Queue &#123; private LinkedList linkedList; public Queue() &#123; linkedList = new LinkedList(); &#125; public void myAdd(Object obj) &#123; linkedList.addFirst(obj); &#125; public Object myGet() &#123; return linkedList.removeLast(); &#125; public boolean isNull() &#123; return linkedList.isEmpty(); &#125;&#125; 需求：基于LinkedList实现栈数据结构 栈数据结构特点：先进先出 代码实现： 1234567891011121314151617181920212223package com.linkedlistdemo;import java.util.LinkedList;public class Stack &#123; private LinkedList linkedList; public Stack() &#123; linkedList = new LinkedList(); &#125; public void myAdd(Object obj) &#123; linkedList.addFirst(obj); &#125; public Object myGet() &#123; return linkedList.removeFirst(); &#125; public boolean isNull() &#123; return linkedList.isEmpty(); &#125;&#125; 测试代码： 12345678910111213141516171819202122232425package com.linkedlistdemo;public class Test &#123; public static void main(String[] args) &#123; Queue queue = new Queue(); queue.myAdd(\"java01\"); queue.myAdd(\"java02\"); queue.myAdd(\"java03\"); queue.myAdd(\"java04\"); while (!queue.isNull()) &#123; System.out.println(queue.myGet()); &#125; System.out.println(\"---------\"); Stack stack = new Stack(); stack.myAdd(\"php01\"); stack.myAdd(\"php02\"); stack.myAdd(\"php03\"); stack.myAdd(\"php04\"); while (!stack.isNull()) &#123; System.out.println(stack.myGet()); &#125; &#125;&#125;","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"https://helayxy.github.io/tags/Java/"}]},{"title":"自定义异常","date":"2020-01-05T14:26:31.000Z","path":"2020/01/05/自定义异常/","text":"需求： 在本程序中，对于除数是负数，视为异常。 步骤： 自定义异常类； 该类继承Exception。 代码： 1234567891011121314151617181920212223242526272829303132333435363738public class CustomException &#123; public static void main(String[] args) &#123; Demo d = new Demo(); try &#123; int x = d.div(4, -1); System.out.println(\"x=\" + x); &#125; catch (NegativeException e) &#123; System.out.println(e.toString()); System.out.println(\"错误的负数是：\" + e.getValue()); &#125; System.out.println(\"over！\"); &#125;&#125;/** * 自定义异常类，继承Exception */class NegativeException extends Exception &#123; private int value; public NegativeException(String message, int value) &#123; super(message);//显示调用父类的有参构造方法，必须放在第一行 this.value = value; &#125; public int getValue() &#123; return value; &#125;&#125;class Demo &#123; int div(int a, int b) throws NegativeException &#123; if (b &lt; 0) &#123; throw new NegativeException(\"出现了除数是负数的情况/by negative\", b); &#125; return a / b; &#125;&#125; 注意点： throws和throw的区别： throws使用在函数上；throw使用在函数内； throws后面跟异常类，可以跟多个，用逗号隔开；throw后跟异常对象。","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"https://helayxy.github.io/tags/Java/"}]},{"title":"单例设计模式介绍","date":"2019-12-10T12:03:26.000Z","path":"2019/12/10/单例设计模式介绍/","text":"1.什么是单例模式： 在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。 2.单例模式的定义与特点： 定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。 特点： 单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点； 3.单例模式的实现： 单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。 Singleton 模式通常有两种实现形式： 饿汉式： 12345678910111213141516package singleton;/** * 饿汉式单例 * 特点：类一旦加载就创建一个单例，保证在调用getInstance方法之前单例已经存在了 */public class HungrySingleton &#123; private static final HungrySingleton instance = new HungrySingleton(); //私有构造，避免外部初始化 private HungrySingleton() &#123; &#125; //静态公有方法，获取该实例对象 public static HungrySingleton getInstance() &#123; return instance; &#125;&#125; 懒汉式第一种： 12345678910111213141516171819202122package singleton;/** * 懒汉式单例 * 特点：只有在调用getInstance方法时才会创建实例对象 */public class LazySingleton &#123; private static LazySingleton instance = null; private LazySingleton() &#123; &#125; /** * 问题： * 使用synchronized关键字修饰，可以保证线程安全性； * 但同时有synchronized关键字修饰，所以该多线程访问时，都要判断锁，会导致效率较低 */ public static synchronized LazySingleton getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; 懒汉式第二种： 123456789101112131415161718192021222324package singleton;/** * 懒汉式更好的解决方案：使用双判断的方式 */public class Lazy &#123; public static Lazy instance = null; private Lazy() &#123; &#125; /** * 使用双重判断的方式来解决懒汉式的效率问题，即当一个线程创建了该实例对象，以后的线程访问的时候该对象 * 就不为null，既不用再去判断锁了，这样可以减少判断锁的次数，提高了效率 */ public static Lazy getInstance() &#123; if (instance == null) &#123; //静态方法的锁使用的是改静态方法所在类的class文件对象 synchronized (Lazy.class) &#123; if (instance == null) &#123; instance = new Lazy(); &#125; &#125; &#125; return instance; &#125;&#125; 1.懒汉式和饿汉式的区别： 懒汉式的特点在于实例的延迟（所以是懒汉式）加载； 2.懒汉式有什么问题： 如果多线程访问时会出现安全问题，可以加同步（synchronized）来解决，但是效率较低 3.怎么解决懒汉式效率低的问题： 可以使用双重判断可以解决这个问题 4.加同步的时候，使用的锁是哪一个： 该类所属的字节码文件对象（静态）","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://helayxy.github.io/tags/设计模式/"}]},{"title":"ElementUI的表单验证问题","date":"2019-12-09T15:04:11.000Z","path":"2019/12/09/ElementUI的表单验证问题/","text":"1.当需要验证的字段是数字类型的时候，需要使用 v-model.number 来绑定，否则验证的时候会当做字符串处 理，结果就无法验证，代码如下所示： 123&lt;el-form-item label=&quot;好评数&quot; prop=&quot;detail.praise_number&quot; style=&quot;width:20.7%&quot;&gt; &lt;el-input v-model.number=&quot;profileExtForm.detail.praise_number&quot; auto-complete=&quot;off&quot; placeholder=&quot;请输入数字类型好评数&quot; clearable&gt;&lt;/el-input&gt; 2.校验规则需要指定number类型： 123'detail.praise_number': [ &#123;type: 'number', required: true, message: '请输入数字类型好评数', trigger: 'blur'&#125;], 3.嵌套表单校验： 当需要校验的数据类型为多个对象时就需要用到表单的嵌套校验，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112data() &#123; return &#123; profileExtForm: &#123; id: '', name: '', sex: '', age: '', region: '', qualification: '',//心理咨询师资质 introduction: '',//自我介绍 proficiency: '',//擅长领域 studio: '', phone: '', create_time: new Date(), update_time: new Date(), state: &#123; id: '', name: '', free: '', price: '', certificate: '', we_chat: '', qq: '', address: '', update_time: '', create_time: '' &#125;, detail: &#123; psychologist_id: '', psychologist_name: '', organization_name: '', organization_address: '', praise_number: '', praise_grade: '', visit_number: '', platform_year: '', message: '',//留言数 create_time: '', update_time: '' &#125; &#125;, profileExtFormRules: &#123; /*简介信息校验规则*/ name: [ &#123;required: true, message: '请输入姓名', trigger: 'blur'&#125; ], sex: [ &#123;required: true, message: '请选择性别', trigger: 'change'&#125; ], age: [ &#123;required: true, message: '请输入年龄', trigger: 'blur'&#125; ], region: [ &#123;required: true, message: '请输入所在地区', trigger: 'blur'&#125; ], qualification: [ &#123;required: true, message: '请选择资质认证', trigger: 'change'&#125; ], proficiency: [ &#123;required: true, message: '请输入擅长领域', trigger: 'blur'&#125; ], phone: [ &#123;required: true, message: '请输入手机号', trigger: 'blur'&#125;, &#123;pattern: /^1[34578]\\d&#123;9&#125;$/, message: '请输入合法的手机号', trigger: 'blur'&#125;, ], create_time: [ &#123;type: 'date', required: true, message: '请选择创建时间', trigger: 'change'&#125; ], /*状态信息校验规则*/ 'state.free': [ &#123;required: true, message: '请选择工作状态', trigger: 'change'&#125; ], 'state.price': [ &#123;required: true, message: '请输入收费标准', trigger: 'blur'&#125; ], 'state.certificate': [ &#123;required: true, message: '请输入所持证书', trigger: 'blur'&#125; ], 'state.we_chat': [ &#123;required: true, message: '请输入微信联系方式', trigger: 'blur'&#125; ], 'state.qq': [ &#123;required: true, message: '请输入QQ联系方式', trigger: 'blur'&#125; ], 'state.address': [ &#123;required: true, message: '请输入所在详细地址', trigger: 'blur'&#125; ], /* 详情信息校验规则*/ 'state.organization_name': [ &#123;required: false, message: '请输入所在机构名称', trigger: 'blur'&#125; ], 'state.organization_address': [ &#123;required: false, message: '请输入所在机构地址', trigger: 'blur'&#125; ], 'detail.praise_number': [ &#123;type: 'number', required: true, message: '请输入数字类型好评数', trigger: 'blur'&#125; ], 'detail.praise_grade': [ &#123;required: true, message: '请选择好评等级', trigger: 'change'&#125; ], 'detail.visit_number': [ &#123;required: true, message: '请输入访问量', trigger: 'blur'&#125; ], 'detail.message': [ &#123;required: true, message: '请输入留言数', trigger: 'blur'&#125; ], 'detail.platform_year': [ &#123;required: true, message: '请输入入住平台时长', trigger: 'blur'&#125; ] &#125; &#125;&#125;,","comments":true,"tags":[{"name":"ElementUI","slug":"ElementUI","permalink":"https://helayxy.github.io/tags/ElementUI/"}]},{"title":"Hexo博客yilia主题添加背景音乐","date":"2019-12-08T01:44:27.000Z","path":"2019/12/08/Hexo博客yilia主题添加背景音乐/","text":"1.打开网易云音乐https://music.163.com/，复制背景音乐的外链播放器代码，如何使用外链播放器请看文章末尾 2.引入外链播放器代码： 在themes/yilia/layout/_partial/left-col.ejs文件最后一个nav标签内添加外链播放器代码，如下所示： 12345678910111213&lt;nav class=&quot;header-nav&quot;&gt; &lt;div class=&quot;social&quot;&gt; &lt;% for (var i in theme.subnav)&#123; %&gt; &lt;a class=&quot;&lt;%= i %&gt;&quot; target=&quot;_blank&quot; href=&quot;&lt;%- url_for(theme.subnav[i]) %&gt;&quot; title=&quot;&lt;%= i %&gt;&quot;&gt;&lt;i class=&quot;icon-&lt;%= i %&gt;&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;%&#125;%&gt; &lt;/div&gt; &lt;!-- 网易云音乐插件 --&gt; &lt;% if (theme.music &amp;&amp; theme.music.enable)&#123; %&gt; &lt;div style=&quot;position:absolute; bottom:120px left:auto; width:85%&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;240&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=&lt;%=theme.music.id||1365514326%&gt;&amp;auto=&lt;%=theme.music.autoplay?1:0%&gt;&amp;height=32&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;% &#125; %&gt;&lt;/nav&gt; 注意：一定要放在&lt;nav&gt;和&lt;/nav&gt;之内，还有网易云音乐很多歌曲是不支持生成外链播放器的 3.在yilia主题配置文件_config.yml末尾添加如下属性配置： 1234music: enable: true id: 1365514326 # 网易云分享的ID autoplay: true # 是否开启自动播放 4.说明： left-col.ejs文件中添加的外链播放器代码笔者添加了一些判断和表达式，作用在于当_config.yml中配置了背景音乐的id，即id: 1365514326 # 网易云分享的ID。表达式中的id，即&lt;%=theme.music.id||1365514326%&gt;将不再生效。即以配置文件中的id为主，当配置文件中未配置背景音乐id时，表达式中id才生效 5.如何使用外链播放器： 在网页版（music.163.com）进入单曲、歌单、专辑、电台节目页面后，点击 “生成外链播放器” 链接。 歌单和专辑外链播放器可以选择大中小三种尺寸，单曲和电台节目可以选择中小两种尺寸。你可以选择最适合你网站设计的尺寸。 还可以选择是否要自动播放，打上勾后，别人访问网站时播放器会自动开始播放。 最后将播放器的代码黏贴到你的网站上，大功告成！","comments":true,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://helayxy.github.io/tags/Hexo/"}]},{"title":"echarts图表x，y轴的设置","date":"2019-12-06T14:13:45.000Z","path":"2019/12/06/echarts图表x，y轴的设置/","text":"xAxis属性代表echarts图表的x轴，设置代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940xAxis : [ &#123; type : 'category', // type:坐标轴类型，默认为category /* 其他类型： 1.'value'：数值轴，适用于连续数据； 2.'category'：类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据； 3.'time'：时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度； 4.'log'：对数轴。适用于对数数据。 */ data : ['上海','北京'], //x轴下面的数据 axisTick: &#123; show: false, //是否显示网状线 默认为true alignWithLabel: true &#125;, //用于设置x轴下面的字体 axisLabel:&#123; show:true, //这里的show用于设置是否显示x轴下的字体 默认为true /* interval： 设置为0，表示强制显示所有标签; 设置为1，表示隔一个标签显示一个标签； 设置为2，表示隔两个标签显示一个标签，以此类推。 */ interval:0, //textStyle表示x轴下的字体的样式 textStyle:&#123; color:'#333', fontSize:13 &#125; &#125;, axisLine:&#123; show:true, //这里的show用于设置是否显示x轴那一条线，默认为true lineStyle:&#123; //lineStyle用来设置x轴那一条线的样式 color:'#6FC6F3', width:2, //轴线的粗细，我写的是2，最小为0，值为0的时候线隐藏 &#125; &#125; &#125;,] yAxis属性代表echarts图表的y轴，样式设置方式与x轴的方式是一样，就是设置的属性会有所差异： 1234567891011121314151617181920212223242526272829303132333435yAxis: [&#123; //上面的三个值可以根据自己需求随意设置，不设置时会根据图中的值自动生成相应的值 min: 0, //y轴的最小值 max: 100, //y轴最大值 interval: 20, //值之间的间隔 type: 'value', //type:坐标轴类型，默认为value /* 其他类型： 1.'value'：数值轴，适用于连续数据； 2.'category'：类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据； 3.'time'：时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也 有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度； 4.'log'：对数轴。适用于对数数据。 */ //是否显示网状线 默认为true splitLine: &#123; show: false &#125;, //用于设置y轴的字体 axisLabel: &#123; show: true, //这里的show用于设置是否显示y轴下的字体，默认为true textStyle: &#123; //textStyle里面写y轴下的字体的样式 color: '#333', fontSize: 13 &#125; &#125;, //用于设置y轴的那一条线 axisLine: &#123; show: true, //这里的show用于设置是否显示y轴那一条线，默认为true lineStyle: &#123; //lineStyle里面写y轴那一条线的样式 color: '#6FC6F3', width: 2, //轴线的粗细 我写的是2 最小为0，值为0的时候线隐藏 &#125; &#125; &#125;]","comments":true,"tags":[{"name":"echarts、前端","slug":"echarts、前端","permalink":"https://helayxy.github.io/tags/echarts、前端/"}]},{"title":"npm不同方式安装的区别","date":"2019-12-06T14:11:51.000Z","path":"2019/12/06/npm不同方式安装的区别/","text":"npm install X: 会把X包安装到node_modules目录中 不会修改package.json 之后运行npm install命令时，不会自动安装X npm install X –save: 会把X包安装到node_modules目录中 会在package.json的dependencies属性下添加X 之后运行npm install命令时，会自动安装X到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，会自动安装X到node_modules目录中 **npm install X –save-dev:** 会把X包安装到node_modules目录中 会在package.json的devDependencies属性下添加X 之后运行npm install命令时，会自动安装X到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，不会自动安装X到node_modules目录中 使用原则: 运行时需要用到的包使用–save，否则使用–save-dev","comments":true,"tags":[{"name":"npm、前端","slug":"npm、前端","permalink":"https://helayxy.github.io/tags/npm、前端/"}]},{"title":"My Personal Views on AI","date":"2019-11-27T14:19:34.000Z","path":"2019/11/27/My-Personal-Views-on-AI/","text":"​ The technology of artificial intelligence,also known as AI for short, has recently recieved both criticism and appreciation, as indicated in many news articles. (反对意见）On the one hand,AI is denounced now that many people will accordingly threaten to lose their livelihood in the near future.（支持意见）On the other hand,some insist that the AI technology is able to boost productivity and efficiency as well as enables us to lead a better and more colorful life.（我的意见）From my view of point,it is an undeniable fact that AI has a profound and positive bearing on the way people study and work.(总体社会利弊看法➕自己观点) ​ （优点一）To begin with,AI plays a pivotal role in making our life more interesting and convenient.For instance,we used to be,to some extent ,harrowed and tormented by some jejune and monotonous work which is best characterized by repeating the same process time after time, day after day.However,with the aids of AI,currently we find the way to hand this kind of work to robots who can do such chores unceasingly for twenty-four hour a day while ensuring more precision than human hands.As a result,it can considerably enhance the quality of commodities and at the same time reduce production costs as efforts of contributing to higher standards of life for people. ​ （优点二） Also,benefiting from AI,now a single mobile phone suffices to do all the tricks.The philosophy and model of smart homes,like,is in full swing and gaining momentum day by day.Hopefully,it won’t take long for us to be served with a well-prepared meal just with a click on the phone when we are spent and wore out after one-day ’s hard work and study.In addition to that,we needn’t to feel irritable and vexed about the tedious housework. It is owing to AI that we have chance to emancipate our hands.Thus,we are set to gain more leisure time than ever before to enjoy the fairness of life and go out to embrace the sunshine. ​ （转折提及少量缺点）However,while we give credit to the positive influence of AI of human development,we should never neglect its negative side.（转折）（举例缺点）The most common one is that some people may risk losing their job as a result of being supplanted by more advanced manufacturing machines or even robots. As of the drawbacks resulting from AI,Mao Tse-tung,the founder of the People’s Republic of China,once said,”Where there is revolution,there is sacrifice.”What’s more,nothing is immaculate in the world ,so does the AI technology.（指出有缺点不可怕可以克服） ​ （总结优点大于缺点） Taking into account all these factors,it’s not difficult to come to the conclusion that the disadvantages brought by AI pale in comparison with the advantages.In terms of the view towards AI,we ought not to throw the baby out with the bath water.Consequently,we need to spare no efforts to draw upon the most advanced technology so as to keep abreast of the times and lead a brighter and better life.","comments":true,"tags":[{"name":"AI","slug":"AI","permalink":"https://helayxy.github.io/tags/AI/"}]},{"title":"解决Git本地仓库上传不到GitHub远程仓库问题","date":"2019-11-21T12:00:02.000Z","path":"2019/11/21/解决Git本地仓库上传不到GitHub远程仓库问题/","text":"1.查看本地仓库和远程仓库的连接方式： 1git remote -v 12origin https://github.com/Helayxy/study-notes.git (fetch)origin https://github.com/Helayxy/study-notes.git (push) 结果若是https开头则是https连接方式，这种方式一般不会出现问题，若是git开头，说明ssh方式 2.删除连接方式： 1git remote rm origin 3.切换为https连接方式： 查看GitHub上的仓库地址，选择https方式，如下图所示； 1https://github.com/Helayxy/learning-materials.git 使用https方式添加远程仓库： 1git remote add origin https://github.com/Helayxy/learning-materials.git 4.使用https连接方式一般情况下上传、拉取代码都没有问题","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://helayxy.github.io/tags/Git/"}]},{"title":"使用Xshell连接VirtualBox中的CentOS7","date":"2019-11-21T11:57:23.000Z","path":"2019/11/21/使用Xshell连接VirtualBox中的CentOS7/","text":"一、下载CentOS7： 1.来到这个网址选择适合自己电脑操作系统的CentOS7的镜像（一般选择第一个，即for CentOS 7 x86_64 iso images这个版本的） 2.进入该版本的链接地址，The following mirrors in your region should have the ISO images available:表示当前所在国家或地区的镜像；Other mirrors further away:表示周边国家或地区的镜像。这里我们一般选择当前所在国家或地区的镜像，因为这样下载速度较快 3.选择阿里云的镜像，这个链接地址，下载CentOS-7-x86_64-DVD-1810.iso 这个版本的镜像，centos7的大小约为4个多G，下载可能需要四五分钟 二、下载VirtualBox： 1.进入腾讯软件中心官网，搜索VirtualBox，选择下载 2.默认安装即可，第二步注意需要点击VirtualBox Networking，选择将整个功能安装到本机硬盘，接下来一路“下一步”即可 3.注意安装过程会提示网络界面的警告，全部选择“是”即可，不然可能出在最后虚拟机不能上网 三、使用VirtualBox打开CentOS7 1.打开VirtualBox，选择新建，填写虚拟电脑的名称，版本这里选择Red Hat 64-bit，点击下一步 2.下面的步骤全部选择默认即可 3.打开虚拟机，根据向导设置语言，选择中文 4.中间过程会出现警告框让设置密码，自行设置即可 5.安装过程中还会出现让你分配内存的警告框，点击进去，点击左上角的“完成”即可 四、网络设置 1.在VirtualBox中选择设置，找到网络，在接有网线的前提下，选择桥接网卡，点击“OK” 2.输入用户名和密码登录成功后，执行cd /etc/sysconfig/nerwork-scripts进入该目录 3.ls列出nerwork-scripts这个目录下的所有文件，选择ifcfg-en*开头的文件，每个人的这个文件名不一样 4.vi ifcfg-en*这个文件，进入编辑模式，将文件的最后一行的ONBOOT的值由no置位yes，按Esc键退出编辑模式，按下：wq进行保存退出（：q！表示不保存强制退出 ） 5.退出后执行service network restart命令中心启动网络配置 6.使用ip addr查看网络情况，注意：CentOS7已经不支持ipconfig命令，所以这个命令在CentOS7中无效 五、Xshell连接CentOS7 1.打开Xshell连接工具，选择新建，在主机一栏填写ip addr命令查看到的网络地址 2.选择用户身份验证，填写CentOS7中的用户名和密码 3.没有其他情况应该可以连接成功","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://helayxy.github.io/tags/Linux/"}]},{"title":"关于web.xml文件<web app>标签报错问题","date":"2019-11-21T11:55:49.000Z","path":"2019/11/21/关于web-xml文件-web-app-标签报错问题/","text":"一、问题描述： 当使用IDEA新建一个Web项目时，会在/WEB-INF目录下自动创建一个web.xml的配置文件，当在该配置文件中添加项目需要的代码后，这时会显示报错； 二、问题原因： 这是因为在上有这样一段代码： 123&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt; 这段代码要求我们在web.xml中编写的相关配置信息必须按照一定的规范和顺序来配置； 三、解决方案： 使用如下代码替换标签即可： 123456&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://java.sun.com/xml/ns/javaee ttp://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt;","comments":true,"tags":[{"name":"Web","slug":"Web","permalink":"https://helayxy.github.io/tags/Web/"}]},{"title":"关于Tomcat位数问题","date":"2019-11-21T11:54:34.000Z","path":"2019/11/21/关于Tomcat位数问题/","text":"问题描述 今天在IDEA中新建一个Web项目，启动Tomcat报了如下的错误： 1[C:\\Deveploment tools\\apache-tomcat-8.0.52\\bin\\tcnative-1.dll:Can't load 32-bit. dll on a AMD 64-bit platform] 报错原因 Tomcat的bin目录下的tcnative-1.dll位数与电脑操作系统位数不匹配，这里的tcnative-1.dll位数是32位的，电脑操作系统位数的位数是64位的，所以启动Tomcat会报这样的错误 解决方案 1.来到这个网站 2.下载相应版本的文件 3.解压：在bin目录下有一个x64文件夹，该文件夹下就是64位的tcnative-1.dll文件 4.替换：删除原tomcat的bin目录下的32位的tcnative-1.dll文件，将64位的tcnative-1.dll添加进去 5.重启Tomcat即可，此时将不再报错","comments":true,"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://helayxy.github.io/tags/Tomcat/"}]},{"title":"Chrome浏览器添加Vue.js插件","date":"2019-11-21T11:53:23.000Z","path":"2019/11/21/Chrome浏览器添加Vue-js插件/","text":"第一步： 在这里下载压缩包并解压到本地； 第二步： 1.下载完成后打开命令行cmd进入vue-devtools-master文件夹； 2.在vue-devtools-master文件夹下运行cnpm install； 3.运行过上面的命令后，运行cnpm run build命令； 说明：npm run build 执行完，会在shells&gt;chrome下的src文件夹里生成几个js文件； 注意：若不运行npm run build命令，则在加载扩展程序时会报错； 第三步： 1.打开shells&gt;chrome&gt;manifest.json，并把json文件的”persistent”:false改成true； 2.打开chrome浏览器，打开更多工具&gt;扩展程序； 3.再点击加载已解压的扩展程序，然后把shells&gt;chrome文件夹放入； 4.完成上述步骤vue.js的插件就算安装成功了；","comments":true,"tags":[{"name":"插件","slug":"插件","permalink":"https://helayxy.github.io/tags/插件/"}]},{"title":"解决Web项目缺少Maven依赖问题","date":"2019-11-21T11:48:36.000Z","path":"2019/11/21/解决Web项目缺少Maven依赖问题/","text":"一、问题描述 启动服务器运行项目时报了如下错误： 1java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener 二、报错原因： 没有添加Maven依赖 三、解决方法： 1.右击项目，选择properties 2.选择Deployment Assembly 3.选择Add -&gt; Java Build Path Entries -&gt; Next 4.选择Maven Dependencies -&gt; Finish -&gt; Apply -&gt; ok 5.移除项目，重新添加至Tomcat 6.重启server即可正常运行项目","comments":true,"tags":[{"name":"Maven","slug":"Maven","permalink":"https://helayxy.github.io/tags/Maven/"}]},{"title":"node-sass不支持当前系统环境","date":"2019-11-21T11:47:31.000Z","path":"2019/11/21/node-sass不支持当前系统环境/","text":"1.问题描述： Node Sass does not yet support your current environment: Windows 64-bit 翻译过来就是说：node sass不支持当前系统环境 2.解决方案： 卸载原来不适合当前本机环境的node sass，重新安装适合本机的node sass 3.卸载： 1cnpm uninstall --save node-sass 4.重新安装： 1cnpm install --save node-sass 注意：使用cnpm的前提是已经配置好了cnpm的镜像 5.若没有配置cnpm，则使用npm进行卸载和安装： 1卸载：npm uninstall --save node-sass 1安装：npm install --save node-sass 注意：使用npm安装可能会出现安装较慢的问题，这是因为npm使用的是国外的镜像","comments":true,"tags":[{"name":"前端","slug":"前端","permalink":"https://helayxy.github.io/tags/前端/"}]},{"title":"Linux系统下安装JDK","date":"2019-11-21T11:44:16.000Z","path":"2019/11/21/Linux系统下安装JDK/","text":"1.将linux版本jdk1.8的tar压缩包上传至虚拟机任意位置 123[root@localhost /]# lsbin dev home jdk-8u211-linux-x64.tar.gz lib media opt root sbin sys usrboot etc lib64 mnt proc run srv tmp var 2.解压 1tar -zxvf jdk-8u131-linux-x64.tar.gz 3.查看解压是否成功 123[root@localhost /]# lsbin dev home jdk-8u211-linux-x64.tar.gz lib media opt root sbin sys usrboot etc jdk1.8.0_211 leyou lib64 mnt proc run srv tmp var 可以看到有jdk1.8.0_211文件夹，表示解压成功！ 4.删除没有用的压缩包 12[root@localhost /]# rm jdk-8u211-linux-x64.tar.gzrm：是否删除普通文件 \"jdk-8u211-linux-x64.tar.gz\"？y 5.创建jdk的安装位置 1[root@localhost /]# mkdir /usr/java 说明：我这里安装到usr目录下的java文件夹中 6.移动解压后的jdk至指定的安装位置 1[root@localhost java]# mv /jdk1.8.0_211 /usr/java 7.修改环境变量 1[root@localhost jdk1.8.0_211]# vi /etc/profile 说明：/etc/profile为系统的配置文件，在改文件末尾添加如下配置信息： 12345export JAVA_HOME=/usr/java/jdk1.8.0_211export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib:$CLASSPATHexport JAVA_PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/binexport PATH=$PATH:$&#123;JAVA_PATH&#125; 使用：wq保存退出 8.让这个环境变量配置信息立即生效 1[root@localhost jdk1.8.0_211]# source /etc/profile 说明：此命令可以使配置信息立马生效，不使用此命令需要重启虚拟机 9.验证jdk是否安装成功 输入javac命令查看： 12345678910111213141516171819202122232425262728293031323334[root@localhost jdk1.8.0_211]# javac用法: javac &lt;options&gt; &lt;source files&gt;其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:&#123;lines,vars,source&#125; 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:&#123;none,only&#125; 控制是否执行注释处理和/或编译。 -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 -parameters 生成元数据以用于方法参数的反射 -d &lt;目录&gt; 指定放置生成的类文件的位置 -s &lt;目录&gt; 指定放置生成的源文件的位置 -h &lt;目录&gt; 指定放置生成的本机标头文件的位置 -implicit:&#123;none,class&#125; 指定是否为隐式引用文件生成类文件 -encoding &lt;编码&gt; 指定源文件使用的字符编码 -source &lt;发行版&gt; 提供与指定发行版的源兼容性 -target &lt;发行版&gt; 生成特定 VM 版本的类文件 -profile &lt;配置文件&gt; 请确保使用的 API 在指定的配置文件中可用 -version 版本信息 -help 输出标准选项的提要 -A关键字[=值] 传递给注释处理程序的选项 -X 输出非标准选项的提要 -J&lt;标记&gt; 直接将 &lt;标记&gt; 传递给运行时系统 -Werror 出现警告时终止编译 @&lt;文件名&gt; 从文件读取选项和文件名 输入java -version查看java版本信息： 1234[root@localhost jdk1.8.0_211]# java -versionjava version \"1.8.0_211\"Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode) 输入echo $PATH查看路径： 12[root@localhost jdk1.8.0_211]# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/java/jdk1.8.0_211/bin:/usr/java/jdk1.8.0_211/jre/bin 10.以上都正确则表示jdk安装成功！","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://helayxy.github.io/tags/Linux/"}]},{"title":"Java中关于对象引用的一点思考","date":"2019-11-21T11:42:53.000Z","path":"2019/11/21/Java中关于对象引用的一点思考/","text":"今天在读《Java编程思想》看到了下面一段代码： 1234567891011121314151617181920/** * @author Helay * @date 2019/11/15 21:58 */public class Tank &#123; private int leave; public static void main(String[] args) &#123; Tank tank1 = new Tank(); Tank tank2 = new Tank(); tank1.leave = 7; tank2.leave = 49; System.out.println(\"1:tank1=\" + tank1.leave + \",tank2=\" + tank2.leave); tank1 = tank2; System.out.println(\"2:tank1=\" + tank1.leave + \",tank2=\" + tank2.leave); tank2.leave = 24; System.out.println(\"3:tank1=\" + tank1.leave + \",tank2=\" + tank2.leave); &#125;&#125; 输出结果是什么呢？我想有些同学可能会给出这样的答案： 1:tank1=7,tank2=492:tank1=49,tank2=493:tank1=49,tank2=24 但正确的答案是这样的 1:tank1=7,tank2=492:tank1=49,tank2=493:tank1=24,tank2=24 这就引起我们的一点思考了，为什么第3行的输出是这样的结果呢？ 由于赋值操作的是对象的引用，并且tank1 = tank2;表示tank1 和tank2为同一个对象，所以第3行的输出结果是一样的 如果我们想让这两个对象那个实例相互独立，应该怎么办呢？请看下面的代码： 1234567891011121314151617181920/** * @author Helay * @date 2019/11/15 21:58 */public class Tank &#123; private int leave; public static void main(String[] args) &#123; Tank tank1 = new Tank(); Tank tank2 = new Tank(); tank1.leave = 7; tank2.leave = 49; System.out.println(\"1:tank1=\" + tank1.leave + \",tank2=\" + tank2.leave); tank1.leave = tank2.leave; System.out.println(\"2:tank1=\" + tank1.leave + \",tank2=\" + tank2.leave); tank2.leave = 24; System.out.println(\"3:tank1=\" + tank1.leave + \",tank2=\" + tank2.leave); &#125;&#125; 这时候输出的结果就发生了变化： 1:tank1=7,tank2=492:tank1=49,tank2=493:tank1=49,tank2=24 对，就是这样的结果！tank1.leave = tank2.leave;这行代码操作的对象的属性，由于代码是由上而下地执行，所以即使tank2.leave = 24;这行代码修改了leave的值，但是修改的tank2对象的属性值，所以并不会应影响tank1.leave的值，你看明白了吗？ 最后还要说一句，一定要记得只有new出来的才叫对象那个啊！ 1String s = \"adsf\"; 这样的s不是对象，一定要记清楚啊！","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"https://helayxy.github.io/tags/Java/"}]},{"title":"IDEA去掉SQL语句背景色","date":"2019-11-21T11:41:51.000Z","path":"2019/11/21/IDEA去掉SQL语句背景色/","text":"1.进入file-&gt;settings-&gt;Editor-&gt;Inspections-&gt;SQL 找到No data sources configured和SQL dialect detection两项，去掉后面的对号 2.进入file-&gt;settings-&gt;Editor-&gt;Color Scheme-&gt;General-&gt;Code 选中Injected language fragment，去掉后面Background的对号 3.进入file-&gt;settings-&gt;Editor-&gt;Color Scheme-&gt;General-&gt;Errors and Warnings 选中Warning，去掉后面Background的对号","comments":true,"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://helayxy.github.io/tags/IDEA/"}]},{"title":"git push origin master报错问题","date":"2019-11-21T11:40:37.000Z","path":"2019/11/21/git-push-origin-master报错问题/","text":"1.问题描述： 执行 1$ git push origin master 命令时，出现以下错误信息： 12345678To https://github.com/Helayxy/leyou.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 'https://github.com/Helayxy/leyou.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 2.原因所在： 出现这个问题是因为GitHub中的文件与本地仓库中的文件不同造成的，当修改了GitHub远程仓库中的文件后，在本地仓库进行git push时，便会出现此问题，可以通过如下命令进行代码合并： 1git pull --rebase origin master 3.提交： 最后使用如下命令进行提交： 1git push origin master","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://helayxy.github.io/tags/Git/"}]},{"title":"CentOS7下安装配置Redis","date":"2019-11-21T11:38:42.000Z","path":"2019/11/21/CentOS7下安装配置Redis/","text":"一、安装 官网下载安装包：redis-4.0.9.tar.gz 上传至安装目录下：/usr/local/leyou 修改权限： 1chmod 755 redis-4.0.9.tar.gz 重命名： 1mv redis-4.0.9.tar.gz redis 解压： 1tar -xvf redis-4.0.9.tar.gz 编译安装： 12cd redis # 进入redis目录make &amp;&amp; make install # redis是用C语言编写的，所以需要编译、安装 二、配置 修改安装目录下的redis.conf文件： 1vi redis.conf 修改以下配置： 123#bind 127.0.0.1 # 将这行代码注释，监听所有的ip地址，外网可以访问protected-mode no # 把yes改成no，允许外网访问daemonize yes # 把no改成yes，后台运行 三、启动或停止 Redis提供了服务端命令和客户端命令： redis-server 服务端命令，可以包含以下参数：start 启动stop 停止 redis-cli 客户端控制台，包含参数：-h xxx 指定服务端地址，默认值是127.0.0.1-p xxx 指定服务端端口，默认值是6379 四、设置开机自启 输入命令，新建文件： 1vi /etc/init.d/redis 输入下面内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/bin/sh# chkconfig: 2345 90 10# description: Redis is a persistent key-value databasePATH=/usr/local/bin:/sbin:/usr/bin:/binREDISPORT=6379EXEC=/usr/local/bin/redis-serverREDIS_CLI=/usr/local/bin/redis-cliPIDFILE=/var/run/redis.pidCONF=\"/usr/local/leyou/redis/redis.conf\"case \"$1\" in start) if [ -f $PIDFILE ] then echo \"$PIDFILE exists, process is already running or crashed\" else echo \"Starting Redis server...\" $EXEC $CONF fi if [ \"$?\"=\"0\" ] then echo \"Redis is running...\" fi ;; stop) if [ ! -f $PIDFILE ] then echo \"$PIDFILE does not exist, process is not running\" else PID=$(cat $PIDFILE) echo \"Stopping ...\" $REDIS_CLI -p $REDISPORT SHUTDOWN while [ -x $&#123;PIDFILE&#125; ] do echo \"Waiting for Redis to shutdown ...\" sleep 1 done echo \"Redis stopped\" fi ;; restart|force-reload) $&#123;0&#125; stop $&#123;0&#125; start ;; *) echo \"Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;\" &gt;&amp;2 exit 1 esac 然后：wq保存退出 注意：以下信息需要根据安装目录进行调整： EXEC=/usr/local/bin/redis-server # 执行脚本的地址 REDIS_CLI=/usr/local/bin/redis-cli # 客户端执行脚本的地址 PIDFILE=/var/run/redis.pid # 进程id文件地址 CONF=”/usr/local/src/redis-3.0.2/redis.conf” #配置文件地址 若是和上面的路径一致，则不需要修改任何路径 设置权限： 1chmod 755 /etc/init.d/redis 启动测试： 1/etc/init.d/redis start 启动成功会提示如下信息： 12Starting Redis server...Redis is running... 设置开机自启动 12chkconfig --add /etc/init.d/redischkconfig redis on","comments":true,"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://helayxy.github.io/tags/CentOS/"}]},{"title":"CentOS7下安装部署FastDFS的一些问题","date":"2019-11-21T11:37:04.000Z","path":"2019/11/21/CentOS7下安装部署FastDFS的一些问题/","text":"一、解决CentOS7 yum下载慢的问题 1.备份 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2.配置国内下载源 1curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 二、问题描述 1.今天在做FastDFS的案例的时候使用 ./make.sh 编译的时候报错，错误如下: 1234567891011121314./make.sh:行113: perl: 未找到命令./make.sh:行114: perl: 未找到命令./make.sh:行115: perl: 未找到命令./make.sh:行116: perl: 未找到命令./make.sh:行117: perl: 未找到命令cc -c -o ../common/fdfs_global.o ../common/fdfs_global.c -I../common -I/usr/local/includecc -c -o tracker_proto.o tracker_proto.c -I../common -I/usr/local/includecc -c -o tracker_mem.o tracker_mem.c -I../common -I/usr/local/includecc -c -o tracker_service.o tracker_service.c -I../common -I/usr/local/includetracker_service.c: 在函数‘tracker_service_init’中:tracker_service.c:139:18: 错误：‘O_NOATIME’未声明(在此函数内第一次使用) O_NONBLOCK | O_NOATIME)) != 0) ^tracker_service.c:139:18: 附注：每个未声明的标识符在其出现的函数内只报告一次 解决方案：安装相应的命令即可，执行以下命令： 1yum -y install zlib zlib-devel pcre pcre-devel gcc gcc-c++ openssl openssl-devel libevent libevent-devel perl unzip net-tools wget 三、CentOS7防火墙问题 1.查看防火墙状态 1firewall-cmd --state 2.关闭防火墙 1systemctl stop firewalld.service 3.禁止firewall开机启动 1systemctl disable firewalld.service 四、关于CentOS7中IP地址的配置 1.使用ifconfig命令进行查看 12345678910111213141516171819[root@localhost /]# ifconfigenp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.0.41.24 netmask 255.255.252.0 broadcast 10.0.43.255 inet6 2001:250:4816:16:9ca2:d624:a10:a3d0 prefixlen 64 scopeid 0x0&lt;global&gt; inet6 fe80::51a8:852:979a:7a23 prefixlen 64 scopeid 0x20&lt;link&gt; ether 08:00:27:d9:39:fe txqueuelen 1000 (Ethernet) RX packets 8473 bytes 605848 (591.6 KiB) RX errors 0 dropped 60 overruns 0 frame 0 TX packets 547 bytes 75264 (73.5 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 178 bytes 13907 (13.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 178 bytes 13907 (13.5 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 注意：inet 10.0.41.24这个地址才是我们需要配置的地址 2.FastDFS中所有的ip地址配置都要和自己虚拟机的ip地址保持一致，FastDFS默认使用的是22122端口 五、CentOS7中的注意事项： 1.编辑某个文件使用vi命令，vim命令无效 2.启动fastDFS的两个命令： 123service fdfs_trackerd startservice fdfs_storaged start","comments":true,"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://helayxy.github.io/tags/CentOS/"}]},{"title":"CentOS7下安装RabbitMQ","date":"2019-11-21T11:33:52.000Z","path":"2019/11/21/CentOS7下安装RabbitMQ/","text":"由于RabbitMQ是用Erlang编写的，所以需要先安装Erlang语言的运行环境 一、安装Erlang 1.在线安装（需要Linux虚拟机能连接外网） 123yum install esl-erlang_17.3-1~centos~6_amd64.rpmyum install esl-erlang-compat-R14B-1.el6.noarch.rpm 2.离线安装 （1）环境准备（需要以下四个安装包） 1234567esl-erlang_17.3-1~centos~6_amd64.rpmesl-erlang-17.3-1.x86_64.rpmesl-erlang-compat-R14B-1.el6.noarch.rpmrabbitmq-server-3.4.1-1.noarch.rpm （2）开始安装 依次执行以下命令开始安装： 12345rpm -ivh esl-erlang-17.3-1.x86_64.rpm --force --nodepsrpm -ivh esl-erlang_17.3-1~centos~6_amd64.rpm --force --nodepsrpm -ivh esl-erlang-compat-R14B-1.el6.noarch.rpm --force --nodeps 说明： i表示安装，v表示显示安装过程，h表示显示进度； –force：表示强制安装； –nodeps：表示忽略依赖冲突； 二、安装安装RabbitMQ 1.使用下面所示命令进行安装 1rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm --force --nodeps 2.设置配置文件 1cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config 3.修改配置文件，开启用户远程访问 1vi /etc/rabbitmq/rabbitmq.config 123%% Uncomment the following line if you want to allow access to the %% guest user from anywhere on the network. &#123;loopback_users, []&#125; 将 {loopback_users, []}前面的%%和末尾的，去掉，保存退出 4.启动、停止RabbitMQ 12345service rabbitmq-server start #启动service rabbitmq-server stop #关闭service rabbitmq-server restart #重启 5.开启Web界面管理工具 123rabbitmq-plugins enable rabbitmq_management #开启web界面管理工具service rabbitmq-server restart #重启 6.设置开机启动 1chkconfig rabbitmq-server on 7.防火墙开放15672端口 123/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT/etc/rc.d/init.d/iptables save 8.或者关闭防火墙 1systemctl stop firewalld.service 注意：第7步和第8步选择一个即可，关闭防火墙就不需要开放端口了","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://helayxy.github.io/tags/Linux/"}]},{"title":"Advanced Rest Client的安装","date":"2019-11-21T11:25:54.000Z","path":"2019/11/21/Advanced-Rest-Client的安装/","text":"1.Advanced Rest Client是Chrome浏览器的应用，需要在Chrome浏览器中安装 2.Advanced Rest Client的下载地址和密码：c5p2 3.解压这个压缩包，然后在Chrome浏览器中点击右上角按钮选择更多工具—&gt;扩展程序，或者使用如下地址打开：chrome://extensions/ 4.打开开发者模式，点击加载已解压的扩展程序按钮，选择解压好的文件夹，确定即可 5.使用时，点击Chrome的应用按钮，或使用以下地址： chrome://apps/ 6.在第一次初始化时，会卡在一个definitions.json文件，除非翻墙，否则在国内这个文件基本是无法下载的，不过在安装包中有这个文件，所以可以点击选择文件按钮，在解压的文件夹中找到这个文件，点击确定，就可以初始化成功了 7.在调用接口之后可以点击右上角的Save按钮，保存这一次的调用记录，并在左边的History标签中查看 8.这个客户端是基于Chrome浏览器的，当使用这个客户端时，会打开一个浏览器界面","comments":true,"tags":[{"name":"插件","slug":"插件","permalink":"https://helayxy.github.io/tags/插件/"}]}]